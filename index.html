<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>R-Runner: Neon Tunnel</title>
    <style>
        :root { --neon: #00f3ff; --danger: #ff0055; --bg: #050510; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: white; font-family: 'Courier New', monospace; touch-action: none; }
        
        #game-canvas { display: block; }

        /* HUD */
        #hud { position: fixed; top: 20px; width: 100%; display: flex; justify-content: space-around; z-index: 100; pointer-events: none; }
        .stat { background: rgba(0,0,0,0.8); padding: 10px 20px; border: 1px solid var(--neon); border-radius: 5px; box-shadow: 0 0 10px var(--neon); }

        /* Controls Instruction */
        #hint { position: fixed; bottom: 100px; width: 100%; text-align: center; color: var(--neon); opacity: 0.6; pointer-events: none; }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; text-align: center; }
        button { padding: 15px 50px; font-size: 20px; background: var(--neon); border: none; color: black; font-weight: bold; border-radius: 5px; cursor: pointer; margin-top: 20px; box-shadow: 0 0 20px var(--neon); }
    </style>
</head>
<body>

<div id="hud">
    <div class="stat">DEPTH: <span id="depth">0</span>m</div>
    <div class="stat">RC: <span id="rc">0</span></div>
</div>

<div id="hint">DRAG LEFT/RIGHT TO ROTATE THE TUNNEL</div>

<div id="start-screen" class="overlay">
    <h1 style="font-size: 40px; color: var(--neon);">NEON TUNNEL</h1>
    <p>Rotate the tunnel to avoid red obstacles!<br>Collect blue crystals to earn RC.</p>
    <button onclick="startGame()">ENTER THE TUNNEL</button>
</div>

<canvas id="game-canvas"></canvas>

<script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    let gameActive = false;
    let depth = 0, rc = 0;
    let rotation = 0;
    let obstacles = [];
    let crystals = [];
    
    // Web Audio API Synth
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSynth(freq, type, dur, vol) {
        if(!gameActive) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
        osc.start(); osc.stop(audioCtx.currentTime + dur);
    }

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', init);
    init();

    // Input Handling
    let isDragging = false;
    let lastX = 0;
    const handleInput = (x) => {
        if(!gameActive) return;
        let delta = x - lastX;
        rotation += delta * 0.01;
        lastX = x;
    };

    window.onpointerdown = (e) => { isDragging = true; lastX = e.clientX; };
    window.onpointermove = (e) => { if(isDragging) handleInput(e.clientX); };
    window.onpointerup = () => isDragging = false;

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        gameActive = true;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        
        // Background Music Loop
        setInterval(() => {
            if(gameActive) {
                playSynth(110, 'sawtooth', 1, 0.02);
                setTimeout(() => playSynth(164, 'sawtooth', 0.5, 0.02), 250);
            }
        }, 500);

        spawn();
        update();
    }

    function spawn() {
        if(!gameActive) return;
        const angle = Math.random() * Math.PI * 2;
        if(Math.random() < 0.7) {
            obstacles.push({ angle: angle, z: 100, width: 0.8 });
        } else {
            crystals.push({ angle: angle, z: 100 });
        }
        setTimeout(spawn, Math.max(200, 600 - depth/50));
    }

    function update() {
        if(!gameActive) return;
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Draw Tunnel Effect
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
        for(let i=0; i<8; i++) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, (i * 50 + (depth%50)) * 2, 0, Math.PI*2);
            ctx.stroke();
        }

        // Draw Player
        ctx.font = '30px Arial';
        ctx.fillText('ðŸš€', centerX - 15, centerY + 150);

        // Process Obstacles
        obstacles.forEach((obs, i) => {
            obs.z -= 1.5;
            let currentAngle = obs.angle + rotation;
            let x = centerX + Math.cos(currentAngle) * (obs.z * 4);
            let y = centerY + Math.sin(currentAngle) * (obs.z * 4);
            let size = (100 - obs.z) / 2;

            ctx.fillStyle = '#ff0055';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI*2);
            ctx.fill();

            // Collision
            if(obs.z < 40 && obs.z > 30) {
                let distToPlayer = Math.hypot(x - centerX, y - (centerY + 150));
                if(distToPlayer < 40) gameOver();
            }
            if(obs.z < 0) obstacles.splice(i, 1);
        });

        // Process Crystals
        crystals.forEach((cry, i) => {
            cry.z -= 1.5;
            let currentAngle = cry.angle + rotation;
            let x = centerX + Math.cos(currentAngle) * (cry.z * 4);
            let y = centerY + Math.sin(currentAngle) * (cry.z * 4);

            ctx.font = '25px Arial';
            ctx.fillText('ðŸ’Ž', x - 12, y + 12);

            if(cry.z < 40 && cry.z > 30) {
                let distToPlayer = Math.hypot(x - centerX, y - (centerY + 150));
                if(distToPlayer < 40) {
                    rc += 10;
                    playSynth(880, 'sine', 0.1, 0.1);
                    crystals.splice(i, 1);
                }
            }
            if(cry.z < 0) crystals.splice(i, 1);
        });

        depth += 1;
        document.getElementById('depth').innerText = Math.floor(depth/10);
        document.getElementById('rc').innerText = rc;

        requestAnimationFrame(update);
    }

    function gameOver() {
        gameActive = false;
        playSynth(50, 'square', 0.5, 0.2);
        alert(`CRASHED!\nDepth reached: ${Math.floor(depth/10)}m\nRC: ${rc}`);
        location.reload();
    }
</script>
</body>
</html>